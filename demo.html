<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Early Congestion Prediction & Adaptive Routing ‚Äî Live Demo</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Exo+2:wght@300;400;600;700;900&display=swap');

  :root {
    --bg: #050d1a;
    --panel: #0a1628;
    --border: #0f3460;
    --accent: #00d4ff;
    --accent2: #ff6b35;
    --green: #00ff9d;
    --red: #ff3c5a;
    --yellow: #ffd93d;
    --text: #c8e0f4;
    --dim: #4a6fa5;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    font-family: 'Exo 2', sans-serif;
    color: var(--text);
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* Animated grid background */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image:
      linear-gradient(rgba(0,212,255,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,212,255,0.03) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none;
    z-index: 0;
  }

  .everything { position: relative; z-index: 1; }

  /* ‚îÄ‚îÄ HEADER ‚îÄ‚îÄ */
  header {
    padding: 18px 32px;
    border-bottom: 1px solid var(--border);
    background: rgba(10,22,40,0.95);
    display: flex;
    align-items: center;
    justify-content: space-between;
    backdrop-filter: blur(10px);
    position: sticky; top: 0; z-index: 100;
  }
  .logo {
    font-family: 'Share Tech Mono', monospace;
    font-size: 13px;
    color: var(--accent);
    letter-spacing: 2px;
    text-transform: uppercase;
  }
  header h1 {
    font-size: 18px;
    font-weight: 700;
    letter-spacing: 1px;
    color: #fff;
  }
  header h1 span { color: var(--accent); }
  .status-bar {
    display: flex;
    gap: 20px;
    align-items: center;
  }
  .status-pill {
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    padding: 4px 12px;
    border-radius: 20px;
    border: 1px solid;
    letter-spacing: 1px;
  }
  .pill-running { border-color: var(--green); color: var(--green); animation: pulse-pill 1.5s infinite; }
  .pill-paused  { border-color: var(--yellow); color: var(--yellow); }
  @keyframes pulse-pill {
    0%,100% { box-shadow: 0 0 0 0 rgba(0,255,157,0.4); }
    50%      { box-shadow: 0 0 0 6px rgba(0,255,157,0); }
  }

  /* ‚îÄ‚îÄ LAYOUT ‚îÄ‚îÄ */
  .main {
    display: grid;
    grid-template-columns: 1fr 340px;
    grid-template-rows: auto auto;
    gap: 16px;
    padding: 16px 24px;
    max-width: 1400px;
    margin: 0 auto;
  }

  /* ‚îÄ‚îÄ PANELS ‚îÄ‚îÄ */
  .panel {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 16px;
    position: relative;
    overflow: hidden;
  }
  .panel::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 2px;
    background: linear-gradient(90deg, transparent, var(--accent), transparent);
    opacity: 0.5;
  }
  .panel-title {
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    color: var(--accent);
    letter-spacing: 2px;
    text-transform: uppercase;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .panel-title::before {
    content: '';
    width: 6px; height: 6px;
    border-radius: 50%;
    background: var(--accent);
    box-shadow: 0 0 8px var(--accent);
  }

  /* ‚îÄ‚îÄ NETWORK CANVAS ‚îÄ‚îÄ */
  #networkCanvas {
    width: 100%;
    border-radius: 8px;
    display: block;
    background: rgba(0,0,0,0.3);
  }

  /* ‚îÄ‚îÄ CONTROLS PANEL ‚îÄ‚îÄ */
  .controls-panel { grid-column: 2; grid-row: 1 / 3; }

  .ctrl-section { margin-bottom: 20px; }
  .ctrl-label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    color: var(--dim);
    letter-spacing: 1px;
    margin-bottom: 10px;
    text-transform: uppercase;
  }

  /* Sliders */
  .slider-row {
    margin-bottom: 10px;
  }
  .slider-top-row {
    display: flex;
    align-items: center;
    gap: 8px;
    width: 100%;
  }
  .slider-label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    width: 55px;
    color: var(--text);
    flex-shrink: 0;
  }
  .slider-wrap { flex: 1; }
  input[type=range] {
    width: 100%;
    -webkit-appearance: none;
    height: 6px;
    border-radius: 3px;
    outline: none;
    cursor: pointer;
    transition: background 0.3s;
  }
  input[type=range].low    { background: #00ff9d; }
  input[type=range].medium { background: linear-gradient(90deg,#00ff9d,#ffd93d); }
  input[type=range].high   { background: linear-gradient(90deg,#ffd93d,#ff3c5a); }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px; height: 16px;
    border-radius: 50%;
    background: #fff;
    cursor: pointer;
    border: 2px solid var(--accent);
    box-shadow: 0 0 8px rgba(0,212,255,0.6);
    transition: border-color 0.3s, box-shadow 0.3s;
  }
  input[type=range].high::-webkit-slider-thumb {
    border-color: #ff3c5a;
    box-shadow: 0 0 10px rgba(255,60,90,0.7);
  }
  input[type=range].medium::-webkit-slider-thumb {
    border-color: #ffd93d;
    box-shadow: 0 0 8px rgba(255,217,61,0.6);
  }
  .slider-legend {
    display: flex;
    justify-content: space-between;
    font-family: 'Share Tech Mono', monospace;
    font-size: 8px;
    color: var(--dim);
    margin-top: 2px;
  }
  .slider-val {
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    width: 100px;
    text-align: right;
    flex-shrink: 0;
    transition: color 0.3s;
  }
  .slider-val.low    { color: var(--green); }
  .slider-val.medium { color: var(--yellow); }
  .slider-val.high   { color: var(--red); }

  /* Node status cards */
  .node-cards {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 6px;
    margin-bottom: 16px;
  }
  .node-card {
    background: rgba(0,0,0,0.3);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px 6px;
    text-align: center;
    transition: all 0.3s;
  }
  .node-card.congested {
    border-color: var(--red);
    background: rgba(255,60,90,0.08);
    box-shadow: 0 0 12px rgba(255,60,90,0.2);
  }
  .node-card.predicted {
    border-color: var(--yellow);
    background: rgba(255,217,61,0.08);
    box-shadow: 0 0 12px rgba(255,217,61,0.2);
    animation: pulse-yellow 1s infinite;
  }
  @keyframes pulse-yellow {
    0%,100% { box-shadow: 0 0 6px rgba(255,217,61,0.3); }
    50%      { box-shadow: 0 0 16px rgba(255,217,61,0.6); }
  }
  .node-card.ok {
    border-color: var(--green);
    background: rgba(0,255,157,0.05);
  }
  .node-card-id {
    font-size: 18px;
    font-weight: 900;
    color: #fff;
  }
  .node-card-status {
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    letter-spacing: 1px;
    margin-top: 2px;
  }
  .node-card.congested .node-card-status { color: var(--red); }
  .node-card.ok .node-card-status { color: var(--green); }
  .node-card-queue {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    color: var(--dim);
    margin-top: 3px;
  }

  /* Buttons */
  .btn-row { display: flex; gap: 8px; margin-bottom: 16px; }
  .btn {
    flex: 1;
    padding: 10px;
    border: 1px solid;
    border-radius: 8px;
    background: transparent;
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    letter-spacing: 1px;
    cursor: pointer;
    text-transform: uppercase;
    transition: all 0.2s;
  }
  .btn-start { border-color: var(--green); color: var(--green); }
  .btn-start:hover { background: rgba(0,255,157,0.1); box-shadow: 0 0 12px rgba(0,255,157,0.2); }
  .btn-pause { border-color: var(--yellow); color: var(--yellow); }
  .btn-pause:hover { background: rgba(255,217,61,0.1); }
  .btn-reset { border-color: var(--dim); color: var(--dim); }
  .btn-reset:hover { border-color: var(--text); color: var(--text); }

  /* Route display */
  .route-display {
    background: rgba(0,0,0,0.4);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;
  }
  .route-label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    color: var(--dim);
    letter-spacing: 1px;
    margin-bottom: 6px;
  }
  .route-path {
    font-family: 'Share Tech Mono', monospace;
    font-size: 13px;
    color: var(--accent);
    letter-spacing: 1px;
  }
  .route-cost {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    color: var(--dim);
    margin-top: 4px;
  }

  /* ‚îÄ‚îÄ CHARTS ROW ‚îÄ‚îÄ */
  .charts-row {
    grid-column: 1;
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 16px;
  }
  canvas.chart { width: 100% !important; }

  /* Log */
  .log-area {
    background: rgba(0,0,0,0.5);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px;
    height: 120px;
    overflow-y: auto;
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    line-height: 1.8;
  }
  .log-area::-webkit-scrollbar { width: 4px; }
  .log-area::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
  .log-entry { display: flex; gap: 8px; }
  .log-time { color: var(--dim); min-width: 50px; }
  .log-msg-normal { color: var(--text); }
  .log-msg-warn { color: var(--yellow); }
  .log-msg-alert { color: var(--red); }
  .log-msg-route { color: var(--accent); }

  /* Metrics strip */
  .metrics-strip {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
    margin-bottom: 16px;
  }
  .metric-box {
    background: rgba(0,0,0,0.3);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px 12px;
    text-align: center;
  }
  .metric-val {
    font-family: 'Share Tech Mono', monospace;
    font-size: 22px;
    font-weight: 700;
    color: var(--accent);
    line-height: 1;
  }
  .metric-lbl {
    font-size: 10px;
    color: var(--dim);
    margin-top: 4px;
    letter-spacing: 0.5px;
  }

  /* Packet animation dots */
  .packet-dot {
    position: absolute;
    width: 7px; height: 7px;
    border-radius: 50%;
    background: var(--accent);
    box-shadow: 0 0 8px var(--accent);
    pointer-events: none;
    transition: none;
  }

  @media (max-width: 900px) {
    .main { grid-template-columns: 1fr; }
    .controls-panel { grid-column: 1; grid-row: auto; }
    .charts-row { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
<div class="everything">

<header>
  <div class="logo">CN PROJECT // GROUP DEMO</div>
  <h1>Early Congestion Prediction & <span>Adaptive Routing</span></h1>
  <div class="status-bar">
    <div class="status-pill pill-paused" id="statusPill">‚óè READY</div>
    <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:var(--dim)" id="simTime">T = 0.00s</div>
  </div>
</header>

<div class="main">

  <!-- ‚îÄ‚îÄ NETWORK TOPOLOGY ‚îÄ‚îÄ -->
  <div class="panel">
    <div class="panel-title">Network Topology ‚Äî Live View</div>
    <canvas id="networkCanvas" height="320"></canvas>
    <div style="display:flex;gap:20px;margin-top:10px;padding:8px 4px;font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:1px;">
      <span style="color:#00ff9d">‚óè NORMAL &nbsp;‚Äî no issue</span>
      <span style="color:#ffd93d">‚óè PREDICTED ‚Äî congestion coming, already rerouting</span>
      <span style="color:#ff3c5a">‚óè CONGESTED ‚Äî threshold breached</span>
    </div>
  </div>

  <!-- ‚îÄ‚îÄ CONTROLS ‚îÄ‚îÄ -->
  <div class="panel controls-panel">
    <div class="panel-title">Control Panel</div>

    <div class="btn-row">
      <button class="btn btn-start" onclick="startSim()">‚ñ∂ START</button>
      <button class="btn btn-pause" onclick="pauseSim()">‚è∏ PAUSE</button>
      <button class="btn btn-reset" onclick="resetSim()">‚Ü∫ RESET</button>
    </div>

    <div class="ctrl-section">
      <div class="ctrl-label">Traffic Rate per Node ‚Äî drag right = more congestion</div>
      <div id="sliders"></div>
    </div>

    <div class="ctrl-section">
      <div class="ctrl-label">Active Route (Node 1 ‚Üí Node 6)</div>
      <div class="route-display">
        <div class="route-label">CURRENT BEST PATH</div>
        <div class="route-path" id="routePath">1 ‚Üí ? ‚Üí ? ‚Üí 6</div>
        <div class="route-cost" id="routeCost">Calculating...</div>
      </div>
    </div>

    <div class="ctrl-section">
      <div class="ctrl-label">Node Status</div>
      <div class="node-cards" id="nodeCards"></div>
    </div>

    <div class="ctrl-section">
      <div class="ctrl-label">Event Log</div>
      <div class="log-area" id="logArea"></div>
    </div>
  </div>

  <!-- ‚îÄ‚îÄ CHARTS ‚îÄ‚îÄ -->
  <div class="charts-row">
    <div class="panel">
      <div class="panel-title">Queue Length</div>
      <canvas id="queueChart" height="160"></canvas>
    </div>
    <div class="panel">
      <div class="panel-title">Delay (ms)</div>
      <canvas id="delayChart" height="160"></canvas>
    </div>
    <div class="panel">
      <div class="panel-title">Congestion Score</div>
      <canvas id="scoreChart" height="160"></canvas>
    </div>
  </div>

</div><!-- /main -->
</div><!-- /everything -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
<script>

//  SIMULATION STATE

const NODES = [1,2,3,4,5,6];
const EDGES = [[1,2],[1,3],[2,4],[3,4],[4,5],[4,6],[5,6]];

// Node positions on canvas (percentages)
const NODE_POS = {
  1: [0.08, 0.50],
  2: [0.32, 0.15],
  3: [0.32, 0.85],
  4: [0.56, 0.50],
  5: [0.80, 0.15],
  6: [0.80, 0.85],
};

const QUEUE_THRESH = 10;
const DELAY_THRESH = 50;   // ms
const RATE_THRESH  = 80;

let state = {};
let trafficRates = {1:5, 2:15, 3:5, 4:12, 5:5, 6:5};
let running = false;
let simTime = 0;
let simInterval = null;
let bestPath = [];
let packets = [];   // animated packet dots on canvas
let historyLen = 60;
let queueHistory = {};
let delayHistory = {};
let timeLabels = [];
let totalPackets = 0;
let totalReroutes = 0;
let dropsAvoided = 0;
let logEntries = [];

// Prediction thresholds ‚Äî intentionally LOWER than actual congestion thresholds
// This is the core of "early prediction" ‚Äî we act before things go bad
const PREDICT_QUEUE = 6;   // 60% of QUEUE_THRESH (10)
const PREDICT_DELAY = 30;  // 60% of DELAY_THRESH (50ms)
const PREDICT_RATE  = 55;  // 70% of RATE_THRESH  (80)

function initState() {
  state = {};
  NODES.forEach(n => {
    state[n] = { queue: 0, delay: 0, rate: 0, score: 0, predicted: false, congested: false };
  });
  queueHistory = {};
  delayHistory = {};
  NODES.forEach(n => { queueHistory[n] = []; delayHistory[n] = []; });
  timeLabels = [];
  packets = [];
  simTime = 0;
  totalPackets = 0;
  totalReroutes = 0;
  dropsAvoided = 0;
  logEntries = [];
  bestPath = [1,3,4,6];
}

//  SIMULATION LOGIC

function tick() {
  simTime += 0.5;
  document.getElementById('simTime').textContent = `T = ${simTime.toFixed(1)}s`;

  NODES.forEach(n => {
    const rate = trafficRates[n];
    const arrivals = Math.floor(Math.random() * rate * 1.5);
    state[n].queue += arrivals;
    const drain = Math.floor(Math.random() * 8 + 4);
    state[n].queue = Math.max(0, state[n].queue - drain);
    state[n].rate = rate + Math.floor((Math.random()-0.5)*4);
    state[n].delay = state[n].queue * 5; // ms
    totalPackets += arrivals;

    // ‚îÄ‚îÄ ACTUAL congestion score (hits HARD thresholds) ‚îÄ‚îÄ
    let score = 0;
    if (state[n].queue > QUEUE_THRESH) score++;
    if (state[n].delay > DELAY_THRESH) score++;
    if (state[n].rate  > RATE_THRESH)  score++;
    state[n].score = score;

    const wasCongested = state[n].congested;
    const wasPredicted = state[n].predicted;

    // ‚îÄ‚îÄ EARLY PREDICTION (hits soft thresholds before hard ones) ‚îÄ‚îÄ
    let predictScore = 0;
    if (state[n].queue > PREDICT_QUEUE) predictScore++;
    if (state[n].delay > PREDICT_DELAY) predictScore++;
    if (state[n].rate  > PREDICT_RATE)  predictScore++;

    state[n].predicted = predictScore >= 2 && score < 2; // predicted but not yet congested
    state[n].congested = score >= 2;

    // Log state transitions
    if (!wasPredicted && !wasCongested && state[n].predicted) {
      addLog(`‚ö† PREDICTION: Node ${n} trending toward congestion ‚Äî rerouting now`, 'warn');
    }
    if (!wasCongested && state[n].congested) {
      addLog(`‚úó Node ${n} CONGESTED (would've hit this without prediction)`, 'alert');
    }
    if (wasCongested && !state[n].congested && !state[n].predicted) {
      addLog(`‚úì Node ${n} recovered ‚Äî all clear`, 'normal');
    }
    if (wasPredicted && !state[n].predicted && !state[n].congested) {
      addLog(`‚úì Node ${n} prediction cleared`, 'normal');
    }
  });

  // Recalculate best path ‚Äî uses PREDICTION scores so rerouting happens EARLY
  const oldPath = [...bestPath];
  bestPath = findBestPath(1, 6);
  if (JSON.stringify(oldPath) !== JSON.stringify(bestPath)) {
    totalReroutes++;
    dropsAvoided += Math.floor(Math.random()*5+3);
    const reason = bestPath.some(n => state[n].predicted) ? 'early prediction' : 'congestion detected';
    addLog(`‚Ü∫ Rerouted via ${bestPath.join('‚Üí')} (triggered by ${reason})`, 'route');
  }

  // History
  timeLabels.push(simTime.toFixed(1));
  NODES.forEach(n => {
    queueHistory[n].push(state[n].queue);
    delayHistory[n].push(state[n].delay);
    if (queueHistory[n].length > historyLen) { queueHistory[n].shift(); delayHistory[n].shift(); }
  });
  if (timeLabels.length > historyLen) timeLabels.shift();

  spawnPacket();
  updateCanvas();
  updateCharts();
  updateNodeCards();
  updateRouteDisplay();
  updateLog();
}

//  ROUTING ALGORITHM

function getAllPaths(src, dst) {
  const adj = {};
  NODES.forEach(n => adj[n] = []);
  EDGES.forEach(([a,b]) => { adj[a].push(b); adj[b].push(a); });

  const paths = [];
  function dfs(cur, dst, visited, path) {
    if (cur === dst) { paths.push([...path]); return; }
    for (const nb of adj[cur]) {
      if (!visited.has(nb)) {
        visited.add(nb);
        path.push(nb);
        dfs(nb, dst, visited, path);
        path.pop();
        visited.delete(nb);
      }
    }
  }
  dfs(src, dst, new Set([src]), [src]);
  return paths;
}

function pathCost(path) {
  // Use prediction-aware score: predicted nodes cost 1, congested nodes cost 3
  // This ensures rerouting happens at prediction stage, before actual congestion
  return path.reduce((sum, n) => {
    if (state[n].congested) return sum + 3;
    if (state[n].predicted) return sum + 1;
    return sum;
  }, 0);
}

function findBestPath(src, dst) {
  const paths = getAllPaths(src, dst);
  if (!paths.length) return [src, dst];
  return paths.reduce((best, p) => pathCost(p) < pathCost(best) ? p : best, paths[0]);
}

//  PACKET ANIMATION

function spawnPacket() {
  if (bestPath.length < 2) return;
  if (Math.random() > 0.6) return;
  packets.push({ path: [...bestPath], step: 0, t: 0, color: '#00d4ff' });
  // Also spawn some on random edges for visual noise
  const e = EDGES[Math.floor(Math.random()*EDGES.length)];
  packets.push({ path: e, step: 0, t: Math.random(), color: 'rgba(0,212,255,0.25)' });
}

function updatePackets() {
  packets.forEach(p => { p.t += 0.05; });
  packets = packets.filter(p => p.t < 1.0);
}

//  CANVAS DRAWING

const canvas = document.getElementById('networkCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  const w = canvas.parentElement.clientWidth - 32;
  canvas.width = w;
  canvas.height = 320;
}

function getPos(nodeId) {
  const [px, py] = NODE_POS[nodeId];
  return [px * canvas.width, py * canvas.height];
}

function updateCanvas() {
  updatePackets();
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const bestEdges = bestPath.length > 1
    ? bestPath.slice(0,-1).map((n,i) => [n, bestPath[i+1]])
    : [];

  // Draw edges
  EDGES.forEach(([a,b]) => {
    const isBest = bestEdges.some(([x,y]) => (x===a&&y===b)||(x===b&&y===a));
    const [ax,ay] = getPos(a);
    const [bx,by] = getPos(b);
    ctx.beginPath();
    ctx.moveTo(ax,ay); ctx.lineTo(bx,by);
    if (isBest) {
      ctx.strokeStyle = '#00d4ff';
      ctx.lineWidth = 3;
      ctx.shadowColor = '#00d4ff';
      ctx.shadowBlur = 10;
    } else {
      ctx.strokeStyle = 'rgba(15,52,96,0.9)';
      ctx.lineWidth = 1.5;
      ctx.shadowBlur = 0;
    }
    ctx.stroke();
    ctx.shadowBlur = 0;
  });

  // Draw animated packets
  packets.forEach(p => {
    if (p.path.length < 2) return;
    const segLen = p.path.length - 1;
    const totalT = p.t * segLen;
    const seg = Math.min(Math.floor(totalT), segLen - 1);
    const segT = totalT - seg;
    const [ax,ay] = getPos(p.path[seg]);
    const [bx,by] = getPos(p.path[seg+1]);
    const x = ax + (bx-ax)*segT;
    const y = ay + (by-ay)*segT;
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, Math.PI*2);
    ctx.fillStyle = p.color;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 8;
    ctx.fill();
    ctx.shadowBlur = 0;
  });

  // Draw nodes
  NODES.forEach(n => {
    const [x,y] = getPos(n);
    const s = state[n];

    let color, fill, pulseColor;
    if (s.congested) {
      color = '#ff3c5a'; fill = 'rgba(255,60,90,0.18)'; pulseColor = '#ff3c5a';
    } else if (s.predicted) {
      color = '#ffd93d'; fill = 'rgba(255,217,61,0.15)'; pulseColor = '#ffd93d';
    } else {
      color = '#00ff9d'; fill = 'rgba(0,255,157,0.08)'; pulseColor = '#00ff9d';
    }

    // Pulsing glow ring for predicted/congested nodes
    if (s.predicted || s.congested) {
      const pulse = 0.5 + 0.5 * Math.sin(Date.now() / 300);
      ctx.beginPath();
      ctx.arc(x, y, 34 + pulse*4, 0, Math.PI*2);
      ctx.strokeStyle = color + '44';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // Glow ring
    ctx.beginPath();
    ctx.arc(x, y, 28, 0, Math.PI*2);
    ctx.fillStyle = fill;
    ctx.fill();
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.shadowColor = color;
    ctx.shadowBlur = s.predicted || s.congested ? 18 : 10;
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Node circle
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI*2);
    ctx.fillStyle = '#0a1628';
    ctx.fill();
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.stroke();

    // Node label
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 16px "Exo 2", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(n, x, y);

    // State badge below node
    ctx.font = '8px "Share Tech Mono", monospace';
    if (s.congested) {
      ctx.fillStyle = '#ff3c5a';
      ctx.fillText('CONGESTED', x, y + 36);
    } else if (s.predicted) {
      ctx.fillStyle = '#ffd93d';
      ctx.fillText('‚ö† PREDICTED', x, y + 36);
    } else {
      ctx.fillStyle = '#4a6fa5';
      ctx.fillText(`Q:${s.queue}`, x, y + 36);
    }
  });
}

//  CHARTS

const chartDefaults = {
  responsive: true,
  animation: false,
  plugins: { legend: { labels: { color: '#4a6fa5', font: { size: 10, family: 'Share Tech Mono' }, boxWidth: 12 } } },
  scales: {
    x: { ticks: { color: '#4a6fa5', font: { size: 9 }, maxTicksLimit: 6 }, grid: { color: 'rgba(15,52,96,0.5)' } },
    y: { ticks: { color: '#4a6fa5', font: { size: 9 } }, grid: { color: 'rgba(15,52,96,0.5)' } }
  }
};

const nodeColors = { 2:'#00d4ff', 4:'#ff6b35', 1:'#00ff9d', 3:'#ffd93d', 5:'#c77dff', 6:'#ff3c5a' };

const qChart = new Chart(document.getElementById('queueChart'), {
  type: 'line',
  data: {
    labels: [],
    datasets: [2,4].map(n => ({
      label: `Node ${n}`,
      data: [],
      borderColor: nodeColors[n],
      backgroundColor: nodeColors[n]+'22',
      borderWidth: 1.5,
      pointRadius: 0,
      fill: true,
      tension: 0.3
    }))
  },
  options: { ...chartDefaults, plugins: { ...chartDefaults.plugins, annotation: {} } }
});

const dChart = new Chart(document.getElementById('delayChart'), {
  type: 'line',
  data: {
    labels: [],
    datasets: [2,4].map(n => ({
      label: `Node ${n}`,
      data: [],
      borderColor: nodeColors[n],
      borderWidth: 1.5,
      pointRadius: 0,
      tension: 0.3
    }))
  },
  options: chartDefaults
});

const sChart = new Chart(document.getElementById('scoreChart'), {
  type: 'bar',
  data: {
    labels: NODES.map(n=>`N${n}`),
    datasets: [{
      label: 'Score',
      data: NODES.map(()=>0),
      backgroundColor: NODES.map(()=>'rgba(0,212,255,0.3)'),
      borderColor: NODES.map(()=>'#00d4ff'),
      borderWidth: 1
    }]
  },
  options: {
    ...chartDefaults,
    scales: {
      ...chartDefaults.scales,
      y: { ...chartDefaults.scales.y, min: 0, max: 3,
           ticks: { ...chartDefaults.scales.y.ticks, stepSize: 1 } }
    }
  }
});

function updateCharts() {
  qChart.data.labels = [...timeLabels];
  qChart.data.datasets[0].data = [...queueHistory[2]];
  qChart.data.datasets[1].data = [...queueHistory[4]];
  qChart.update('none');

  dChart.data.labels = [...timeLabels];
  dChart.data.datasets[0].data = [...delayHistory[2]];
  dChart.data.datasets[1].data = [...delayHistory[4]];
  dChart.update('none');

  sChart.data.datasets[0].data = NODES.map(n => state[n].score);
  sChart.data.datasets[0].backgroundColor = NODES.map(n =>
    state[n].congested ? 'rgba(255,60,90,0.5)' :
    state[n].predicted ? 'rgba(255,217,61,0.5)' : 'rgba(0,212,255,0.3)');
  sChart.data.datasets[0].borderColor = NODES.map(n =>
    state[n].congested ? '#ff3c5a' :
    state[n].predicted ? '#ffd93d' : '#00d4ff');
  sChart.update('none');
}


//  UI UPDATES

function updateNodeCards() {
  const c = document.getElementById('nodeCards');
  c.innerHTML = NODES.map(n => {
    const s = state[n];
    let cls, label;
    if (s.congested)      { cls = 'congested'; label = 'üî¥ CNGST'; }
    else if (s.predicted) { cls = 'predicted';  label = 'üü° PRED'; }
    else                  { cls = 'ok';         label = 'üü¢ OK'; }
    return `
    <div class="node-card ${cls}">
      <div class="node-card-id">${n}</div>
      <div class="node-card-status">${label}</div>
      <div class="node-card-queue">Q:${s.queue}</div>
    </div>`;
  }).join('');
}

function updateRouteDisplay() {
  document.getElementById('routePath').textContent = bestPath.join(' ‚Üí ');
  const cost = pathCost(bestPath);
  const allPaths = getAllPaths(1,6);
  const hasPredicted = bestPath.some(n => state[n].predicted);
  const hasCongested = bestPath.some(n => state[n].congested);
  let trigger = 'Normal routing';
  if (hasCongested) trigger = '‚ö† Avoiding congested nodes';
  else if (hasPredicted) trigger = '‚ö° Early prediction active';
  document.getElementById('routeCost').textContent =
    `${trigger} | ${allPaths.length} paths evaluated`;
}

function addLog(msg, type='normal') {
  logEntries.unshift({ time: simTime.toFixed(1), msg, type });
  if (logEntries.length > 50) logEntries.pop();
}

function updateLog() {
  const el = document.getElementById('logArea');
  el.innerHTML = logEntries.slice(0,20).map(e =>
    `<div class="log-entry">
      <span class="log-time">[${e.time}s]</span>
      <span class="log-msg-${e.type}">${e.msg}</span>
    </div>`).join('');
}

//  SLIDERS

function sliderClass(val) {
  if (val <= 8)  return 'low';
  if (val <= 16) return 'medium';
  return 'high';
}
function sliderLabel(val) {
  if (val <= 8)  return 'üü¢ LOW TRAFFIC';
  if (val <= 16) return 'üü° MODERATE';
  return 'üî¥ HIGH ‚Äî CONGESTION RISK';
}

function buildSliders() {
  const c = document.getElementById('sliders');
  c.innerHTML = NODES.map(n => {
    const cls = sliderClass(trafficRates[n]);
    return `
    <div class="slider-row">
      <div class="slider-top-row">
        <span class="slider-label">Node ${n}</span>
        <div class="slider-wrap">
          <input type="range" min="1" max="25" value="${trafficRates[n]}" class="${cls}"
            id="sl${n}"
            oninput="
              trafficRates[${n}]=+this.value;
              const c=sliderClass(+this.value);
              this.className=c;
              const v=document.getElementById('sv${n}');
              v.textContent=sliderLabel(+this.value);
              v.className='slider-val '+c;
            "/>
          <div class="slider-legend"><span>LOW</span><span>‚ñ≤ CONGESTION RISK ‚ñ≤</span><span>HIGH</span></div>
        </div>
        <span class="slider-val ${cls}" id="sv${n}">${sliderLabel(trafficRates[n])}</span>
      </div>
    </div>`;
  }).join('');
}

//  CONTROLS

function startSim() {
  if (running) return;
  running = true;
  document.getElementById('statusPill').className = 'status-pill pill-running';
  document.getElementById('statusPill').textContent = '‚óè RUNNING';
  addLog('Simulation started', 'route');
  simInterval = setInterval(tick, 300);
}

function pauseSim() {
  running = false;
  clearInterval(simInterval);
  document.getElementById('statusPill').className = 'status-pill pill-paused';
  document.getElementById('statusPill').textContent = '‚óè PAUSED';
  addLog('Simulation paused', 'warn');
}

function resetSim() {
  pauseSim();
  initState();
  document.getElementById('statusPill').textContent = '‚óè READY';
  updateCanvas();
  updateCharts();
  updateNodeCards();
  updateRouteDisplay();
  updateLog();
  document.getElementById('simTime').textContent = 'T = 0.00s';
}

//  INIT

window.addEventListener('load', () => {
  resizeCanvas();
  window.addEventListener('resize', () => { resizeCanvas(); updateCanvas(); });
  initState();
  buildSliders();
  updateCanvas();
  updateNodeCards();
  updateRouteDisplay();
  updateLog();
  addLog('System ready. Press START to begin.', 'route');
  updateLog();
});
</script>
</body>
</html>